/**
 * main.cpp - VEX Robot Control System (Time-Based Physics Version)
 * 
 * Robot Configuration:
 * - 6-motor drivetrain (all BLUE cartridges - 600 RPM)
 *   - Left: Ports 15, 16, 19 (reversed)
 *   - Right: Ports 1, 2, 3
 * - Complex intake/elevator system (4 motors - all GREEN cartridges - 200 RPM) 
 *   - frontTopMotor: Port 10
 *   - frontMiddleMotor: Port 6
 *   - backMiddleMotor: Port 8
 *   - backTopMotor: Port 9 (initial CCW movement at startup)
 * - Pneumatics:
 *   - Scooper: Port D (controlled by X/B)
 * 
 * SIMPLIFIED AUTONOMOUS:
 * - No encoders needed
 * - No IMU needed
 * - Uses time-based movement: distance = velocity Ã— time
 * - Calibrate speeds once, then use consistent timing
 * 
 * Control Scheme:
 * - Left Stick Y (Axis3): Forward/Backward
 * - Left Stick X (Axis1): Turning (LEFT STICK)
 * - Right Stick X (Axis4): Turning (RIGHT STICK)
 * - R1: Intake middle (Port 6 forward, others run to support)
 * - R2: Intake top (shoot to top - all motors forward)
 * - L1: Intake to bottom storage
 * - L2: Intake to top storage
 * - X: Deploy scooper (Port D)
 * - B: Retract scooper (Port D)
 * - A: Port 6 CCW
 * - Y: Port 6 CW
 * - D-Pad Left: Port 8 CCW
 * - D-Pad Right: Port 10 CCW
 * - D-Pad Up: Port 10 CCW
 * - D-Pad Down: Port 10 CW
 */

#include "main.h"
#include <cmath>

// ==================== MOTOR DECLARATIONS ====================

// DRIVETRAIN - 6 motors (3 per side, all BLUE cartridges - 600 RPM)
pros::Motor leftFront(-15, pros::MotorGearset::blue);      // Port 15 (reversed)
pros::Motor leftMiddle(-16, pros::MotorGearset::blue);     // Port 16 (reversed)
pros::Motor leftBack(-19, pros::MotorGearset::blue);       // Port 19 (reversed)

pros::Motor rightFront(1, pros::MotorGearset::blue);       // Port 1
pros::Motor rightMiddle(2, pros::MotorGearset::blue);      // Port 2
pros::Motor rightBack(3, pros::MotorGearset::blue);        // Port 3

// INTAKE/ELEVATOR SYSTEM - 4 motors (all GREEN cartridges - 200 RPM)
pros::Motor frontTopMotor(10, pros::MotorGearset::green);     // Port 10
pros::Motor frontMiddleMotor(6, pros::MotorGearset::green);   // Port 6
pros::Motor backTopMotor(9, pros::MotorGearset::green);       // Port 9
pros::Motor backMiddleMotor(8, pros::MotorGearset::green);    // Port 8

// ==================== PNEUMATICS ====================

pros::adi::DigitalOut scooper('D');  // Port D - Scooper control (X/B buttons)

// ==================== CONTROLLER ====================
pros::Controller master(pros::E_CONTROLLER_MASTER);

// ==================== CONFIGURATION CONSTANTS ====================

// Deadzone for joysticks
const int JOYSTICK_DEADZONE = 10;

// Motor speeds (RPM) - All intake motors are GREEN (200 RPM max)
const int INTAKE_SPEED = 180;      // RPM for intake operations
const int OUTTAKE_SPEED = 140;     // RPM for outtake operations

// Startup movement for backTopMotor
const int STARTUP_BACKTOP_SPEED = 100;        // RPM for initial CCW movement
const int STARTUP_BACKTOP_TIME = 1000;        // ms to run backTopMotor CCW at startup

// Main loop timing
const int MAIN_LOOP_DELAY = 10;                // ms delay in main control loop

// ==================== TIME-BASED MOVEMENT CALIBRATION ====================

// CALIBRATION: These values determine how far the robot moves in time
// To calibrate: Run the robot at DRIVE_SPEED for CALIBRATION_TIME and measure actual distance
// Then calculate: INCHES_PER_SECOND = measured_distance / (CALIBRATION_TIME / 1000.0)

const int DRIVE_SPEED = 80;              // Motor power for straight driving (0-127)
const int TURN_SPEED = 60;               // Motor power for turning (0-127)
const int STRAFE_SPEED = 80;             // Motor power for strafing (0-127)

// Movement calibration (adjust these after testing!)
const double INCHES_PER_SECOND = 12.0;   // How many inches robot travels per second at DRIVE_SPEED
const double DEGREES_PER_SECOND = 180.0; // How many degrees robot turns per second at TURN_SPEED

// ==================== AUTONOMOUS ROUTINE PARAMETERS ====================

// Autonomous distances and timings
const double AUTO_BLOCKS_DISTANCE = 37.65;      // inches to drive to reach blocks
const int AUTO_INTAKE_TIME = 1500;              // ms to intake 3 blocks
const double AUTO_GOAL_ALIGNMENT_ANGLE = 45.0;  // degrees to turn for goal alignment
const double AUTO_GOAL_APPROACH = 21.75;        // inches to approach goal
const int AUTO_OUTTAKE_TIME = 1600;             // ms to outtake to goal
const double AUTO_LOADER_RETURN = 39.05;        // inches to back up to loader
const double AUTO_LOADER_ANGLE = 180 - AUTO_GOAL_ALIGNMENT_ANGLE;
const double AUTO_LOADER_DRIVE = 11.72;         // inches to drive into loader
const int AUTO_LOADER_TIME = 2200;              // ms for loader to drop blocks
const double AUTO_LOADER_EXIT = AUTO_LOADER_DRIVE;
const double AUTO_LONG_GOAL_DRIVE = 22.73;      // inches to drive to long goal
const int AUTO_LONG_GOAL_TIME = 1800;           // ms to outtake to long goal

// Autonomous delay timings
const int AUTO_PNEUMATIC_DELAY = 200;           // ms after pneumatic actuation
const int AUTO_STEP_DELAY = 100;                // ms between autonomous steps

// ==================== GLOBAL STATE ====================

bool autonomousMode = false;
bool scooperDeployed = false;

// ==================== UTILITY FUNCTIONS ====================

/**
 * Apply joystick deadzone
 */
int applyDeadzone(int value) {
    if (abs(value) < JOYSTICK_DEADZONE) {
        return 0;
    }
    return value;
}

/**
 * Set brake mode for all drivetrain motors
 */
void setDriveBrakeMode(pros::motor_brake_mode_e mode) {
    leftFront.set_brake_mode(mode);
    leftMiddle.set_brake_mode(mode);
    leftBack.set_brake_mode(mode);
    rightFront.set_brake_mode(mode);
    rightMiddle.set_brake_mode(mode);
    rightBack.set_brake_mode(mode);
}

/**
 * Stop all drivetrain motors
 */
void stopDrive() {
    leftFront.move(0);
    leftMiddle.move(0);
    leftBack.move(0);
    rightFront.move(0);
    rightMiddle.move(0);
    rightBack.move(0);
}

/**
 * Set power to left side motors
 */
void setLeftMotors(int power) {
    leftFront.move(power);
    leftMiddle.move(power);
    leftBack.move(power);
}

/**
 * Set power to right side motors
 */
void setRightMotors(int power) {
    rightFront.move(power);
    rightMiddle.move(power);
    rightBack.move(power);
}

// ==================== TIME-BASED MOVEMENT FUNCTIONS ====================

/**
 * Drive straight for a given distance using time
 * distance: inches to travel (negative for backwards)
 */
void driveDistance(double distance) {
    bool forward = distance > 0;
    double absDistance = fabs(distance);
    
    // Calculate time needed: time = distance / speed
    int timeMs = (int)((absDistance / INCHES_PER_SECOND) * 1000.0);
    
    // Set motor power
    int power = forward ? DRIVE_SPEED : -DRIVE_SPEED;
    setLeftMotors(power);
    setRightMotors(power);
    
    // Wait for calculated time
    pros::delay(timeMs);
    
    // Stop
    stopDrive();
}

/**
 * Turn for a given angle using time
 * angle: degrees to turn (positive = right, negative = left)
 */
void turnAngle(double angle) {
    bool turnRight = angle > 0;
    double absAngle = fabs(angle);
    
    // Calculate time needed: time = angle / angular_speed
    int timeMs = (int)((absAngle / DEGREES_PER_SECOND) * 1000.0);
    
    // Set motor power for turning
    if (turnRight) {
        setLeftMotors(TURN_SPEED);
        setRightMotors(-TURN_SPEED);
    } else {
        setLeftMotors(-TURN_SPEED);
        setRightMotors(TURN_SPEED);
    }
    
    // Wait for calculated time
    pros::delay(timeMs);
    
    // Stop
    stopDrive();
}

/**
 * Drive with custom power and time
 * power: motor power (-127 to 127)
 * timeMs: time to drive in milliseconds
 */
void driveForTime(int power, int timeMs) {
    setLeftMotors(power);
    setRightMotors(power);
    pros::delay(timeMs);
    stopDrive();
}

/**
 * Turn with custom power and time
 * power: motor power (-127 to 127) - positive = right, negative = left
 * timeMs: time to turn in milliseconds
 */
void turnForTime(int power, int timeMs) {
    setLeftMotors(power);
    setRightMotors(-power);
    pros::delay(timeMs);
    stopDrive();
}

// ==================== PNEUMATIC FUNCTIONS ====================

/**
 * Deploy the scooper
 */
void deployScooper() {
    scooper.set_value(true);
    scooperDeployed = true;
}

/**
 * Retract the scooper
 */
void retractScooper() {
    scooper.set_value(false);
    scooperDeployed = false;
}

// ==================== INTAKE CONTROL FUNCTIONS ====================

/**
 * Stop all intake motors
 */
void stopIntake() {
    frontTopMotor.move_velocity(0);
    frontMiddleMotor.move_velocity(0);
    backTopMotor.move_velocity(0);
    backMiddleMotor.move_velocity(0);
}

/**
 * Intake middle configuration
 */
void outakeMiddle() {
    frontTopMotor.move_velocity(INTAKE_SPEED);
    frontMiddleMotor.move_velocity(INTAKE_SPEED);
    backTopMotor.move_velocity(INTAKE_SPEED);
    backMiddleMotor.move_velocity(INTAKE_SPEED);
}

/**
 * Outtake to top
 */
void outakeTop() {
    frontTopMotor.move_velocity(INTAKE_SPEED);
    frontMiddleMotor.move_velocity(INTAKE_SPEED);
    backTopMotor.move_velocity(INTAKE_SPEED);
    backMiddleMotor.move_velocity(INTAKE_SPEED);
}

/**
 * Outtake to bottom
 */
void outakeBottom() {
    frontTopMotor.move_velocity(-OUTTAKE_SPEED);
    frontMiddleMotor.move_velocity(-OUTTAKE_SPEED);
    backTopMotor.move_velocity(-OUTTAKE_SPEED);
    backMiddleMotor.move_velocity(-OUTTAKE_SPEED);
}

/**
 * Outtake to storage
 */
void outakeStorage() {
    frontTopMotor.move_velocity(INTAKE_SPEED);
    frontMiddleMotor.move_velocity(INTAKE_SPEED);
    backTopMotor.move_velocity(INTAKE_SPEED);
    backMiddleMotor.move_velocity(INTAKE_SPEED);
}

/**
 * Motor 6 CCW
 */
void motor6CCW() {
    frontMiddleMotor.move_velocity(-INTAKE_SPEED);
}

/**
 * Motor 6 CW
 */
void motor6CW() {
    frontMiddleMotor.move_velocity(INTAKE_SPEED);
}

/**
 * Motor 8 CW
 */
void motor8CW() {
    backMiddleMotor.move_velocity(INTAKE_SPEED);
}

/**
 * Motor 8 CCW
 */
void motor8CCW() {
    backMiddleMotor.move_velocity(-INTAKE_SPEED);
}

/**
 * Motor 10 CCW
 */
void motor10CCW() {
    frontTopMotor.move_velocity(-INTAKE_SPEED);
}

/**
 * Motor 10 CW
 */
void motor10CW() {
    frontTopMotor.move_velocity(INTAKE_SPEED);
}

// ==================== DRIVER CONTROL ====================

/**
 * Holonomic (omni-directional) drive control
 */
void omniDrive(int forward, int strafe, int turn) {
    forward = applyDeadzone(forward);
    strafe = applyDeadzone(strafe);
    turn = applyDeadzone(turn);
    
    int leftPower = forward + strafe + turn;
    int rightPower = forward - strafe - turn;
    
    setLeftMotors(leftPower);
    setRightMotors(rightPower);
}

// ==================== CALIBRATION FUNCTIONS ====================

/**
 * Calibration routine to determine INCHES_PER_SECOND
 * Drive straight for 3 seconds at DRIVE_SPEED, then measure the distance
 */
void calibrateDriveSpeed() {
    pros::lcd::clear();
    pros::lcd::set_text(0, "=== CALIBRATE ===");
    pros::lcd::set_text(1, "Drive Speed Test");
    pros::lcd::set_text(2, "Starting in 2s...");
    pros::delay(2000);
    
    pros::lcd::set_text(2, "Driving...");
    driveForTime(DRIVE_SPEED, 3000); // Drive for 3 seconds
    
    pros::lcd::set_text(2, "DONE!");
    pros::lcd::set_text(3, "Measure distance");
    pros::lcd::set_text(4, "Distance / 3 = in/s");
    
    // Wait for user to read
    pros::delay(5000);
}

/**
 * Calibration routine to determine DEGREES_PER_SECOND
 * Turn for 2 seconds at TURN_SPEED, then measure the angle
 */
void calibrateTurnSpeed() {
    pros::lcd::clear();
    pros::lcd::set_text(0, "=== CALIBRATE ===");
    pros::lcd::set_text(1, "Turn Speed Test");
    pros::lcd::set_text(2, "Starting in 2s...");
    pros::delay(2000);
    
    pros::lcd::set_text(2, "Turning...");
    turnForTime(TURN_SPEED, 2000); // Turn for 2 seconds
    
    pros::lcd::set_text(2, "DONE!");
    pros::lcd::set_text(3, "Measure angle");
    pros::lcd::set_text(4, "Angle / 2 = deg/s");
    
    // Wait for user to read
    pros::delay(5000);
}

// ==================== AUTONOMOUS ROUTINES ====================

/**
 * Left side autonomous routine (simplified time-based version)
 */
void autonomousLeft() {
    pros::lcd::clear();
    pros::lcd::set_text(0, "=== AUTO LEFT ===");
    
    // STEP 1: Deploy scooper
    pros::lcd::set_text(1, "1: Deploy");
    deployScooper();
    pros::delay(AUTO_PNEUMATIC_DELAY);
    
    // STEP 2: Drive to blocks and intake
    pros::lcd::set_text(1, "2: Get blocks");
    
    // Start driving
    setLeftMotors(DRIVE_SPEED);
    setRightMotors(DRIVE_SPEED);
    
    // Start intake after brief delay
    pros::delay(200);
    outakeMiddle();
    
    // Calculate remaining time to reach blocks
    int driveTime = (int)((AUTO_BLOCKS_DISTANCE / INCHES_PER_SECOND) * 1000.0);
    pros::delay(driveTime - 200); // Subtract the 200ms we already waited
    
    // Stop driving
    stopDrive();
    
    // Continue intake
    pros::delay(AUTO_INTAKE_TIME);
    stopIntake();
    
    // STEP 3: Turn and retract scooper
    pros::lcd::set_text(1, "3: Align");
    turnAngle(AUTO_GOAL_ALIGNMENT_ANGLE);
    pros::delay(50);
    retractScooper();
    
    // STEP 4: Score center goal
    pros::lcd::set_text(1, "4: Score center");
    driveDistance(AUTO_GOAL_APPROACH);
    
    outakeBottom();
    pros::delay(AUTO_OUTTAKE_TIME);
    stopIntake();
    
    pros::lcd::set_text(1, "=== COMPLETE ===");
}

/**
 * Right side autonomous routine (simplified time-based version)
 */
void autonomousRight() {
    pros::lcd::clear();
    pros::lcd::set_text(0, "=== AUTO RIGHT ===");
    
    // STEP 1: Deploy scooper
    pros::lcd::set_text(1, "1: Deploy");
    deployScooper();
    pros::delay(AUTO_PNEUMATIC_DELAY);
    
    // STEP 2: Drive to blocks and intake
    pros::lcd::set_text(1, "2: Get blocks");
    
    // Start driving
    setLeftMotors(DRIVE_SPEED);
    setRightMotors(DRIVE_SPEED);
    
    // Start intake after brief delay
    pros::delay(200);
    outakeMiddle();
    
    // Calculate remaining time to reach blocks
    int driveTime = (int)((AUTO_BLOCKS_DISTANCE / INCHES_PER_SECOND) * 1000.0);
    pros::delay(driveTime - 200);
    
    // Stop driving
    stopDrive();
    
    // Continue intake
    pros::delay(AUTO_INTAKE_TIME);
    stopIntake();
    
    // STEP 3: Turn and retract scooper (negative angle for right side)
    pros::lcd::set_text(1, "3: Align");
    turnAngle(-AUTO_GOAL_ALIGNMENT_ANGLE);
    pros::delay(50);
    retractScooper();
    
    // STEP 4: Score center goal
    pros::lcd::set_text(1, "4: Score center");
    driveDistance(AUTO_GOAL_APPROACH);
    
    outakeBottom();
    pros::delay(AUTO_OUTTAKE_TIME);
    stopIntake();
    
    pros::lcd::set_text(1, "=== COMPLETE ===");
}

/**
 * Full autonomous with loader (time-based)
 */
void autonomousFull(bool leftSide) {
    pros::lcd::clear();
    pros::lcd::set_text(0, leftSide ? "=== AUTO LEFT ===" : "=== AUTO RIGHT ===");
    
    int turnDirection = leftSide ? 1 : -1; // 1 for left, -1 for right
    
    // STEP 1: Deploy scooper
    pros::lcd::set_text(1, "1: Deploy");
    deployScooper();
    pros::delay(AUTO_PNEUMATIC_DELAY);
    
    // STEP 2: Drive to blocks and intake
    pros::lcd::set_text(1, "2: Get blocks");
    setLeftMotors(DRIVE_SPEED);
    setRightMotors(DRIVE_SPEED);
    pros::delay(200);
    outakeMiddle();
    int driveTime = (int)((AUTO_BLOCKS_DISTANCE / INCHES_PER_SECOND) * 1000.0);
    pros::delay(driveTime - 200);
    stopDrive();
    pros::delay(AUTO_INTAKE_TIME);
    stopIntake();
    
    // STEP 3: Turn and retract
    pros::lcd::set_text(1, "3: Align");
    turnAngle(AUTO_GOAL_ALIGNMENT_ANGLE * turnDirection);
    pros::delay(50);
    retractScooper();
    
    // STEP 4: Score center goal
    pros::lcd::set_text(1, "4: Score center");
    driveDistance(AUTO_GOAL_APPROACH);
    outakeBottom();
    pros::delay(AUTO_OUTTAKE_TIME);
    stopIntake();
    
    // STEP 5: Back to loader
    pros::lcd::set_text(1, "5: To loader");
    driveDistance(-AUTO_LOADER_RETURN);
    
    // STEP 6: Turn and deploy
    pros::lcd::set_text(1, "6: Align loader");
    turnAngle(AUTO_LOADER_ANGLE * turnDirection);
    pros::delay(100);
    deployScooper();
    
    // STEP 7: Load blocks
    pros::lcd::set_text(1, "7: Load blocks");
    setLeftMotors(DRIVE_SPEED);
    setRightMotors(DRIVE_SPEED);
    pros::delay(200);
    outakeMiddle();
    driveTime = (int)((AUTO_LOADER_DRIVE / INCHES_PER_SECOND) * 1000.0);
    pros::delay(driveTime - 200);
    stopDrive();
    pros::delay(AUTO_LOADER_TIME);
    stopIntake();
    
    // STEP 8: Exit and retract
    pros::lcd::set_text(1, "8: Exit loader");
    driveDistance(-AUTO_LOADER_EXIT);
    pros::delay(100);
    retractScooper();
    
    // STEP 9: Turn to long goal
    pros::lcd::set_text(1, "9: To long goal");
    turnAngle(180 * turnDirection);
    
    // STEP 10: Score long goal
    pros::lcd::set_text(1, "10: Score long");
    driveDistance(AUTO_LONG_GOAL_DRIVE);
    outakeTop();
    pros::delay(AUTO_LONG_GOAL_TIME);
    stopIntake();
    
    pros::lcd::set_text(1, "=== COMPLETE ===");
}

// ==================== INITIALIZATION ====================

void initialize() {
    pros::lcd::initialize();
    pros::lcd::clear();
    pros::lcd::set_text(0, "=== INITIALIZING ===");
    pros::lcd::set_text(1, "Time-Based Mode");
    
    // Set brake modes
    setDriveBrakeMode(pros::E_MOTOR_BRAKE_COAST);
    
    // Startup movement for backTopMotor
    pros::lcd::set_text(2, "Motor startup...");
    backTopMotor.move_velocity(STARTUP_BACKTOP_SPEED);
    pros::delay(STARTUP_BACKTOP_TIME);
    backTopMotor.move_velocity(0);
    
    pros::lcd::set_text(2, "Ready!");
    pros::delay(500);
}

void disabled() {}

void competition_initialize() {}

// ==================== MAIN AUTONOMOUS ====================

void autonomous() {
    autonomousMode = true;
    setDriveBrakeMode(pros::E_MOTOR_BRAKE_HOLD);
    
    // Choose ONE autonomous routine:
    autonomousLeft();           // Simple left side
    // autonomousRight();       // Simple right side
    // autonomousFull(true);    // Full routine - left side
    // autonomousFull(false);   // Full routine - right side
    
    // Or run calibration:
    // calibrateDriveSpeed();
    // calibrateTurnSpeed();
    
    autonomousMode = false;
    setDriveBrakeMode(pros::E_MOTOR_BRAKE_COAST);
}

// ==================== DRIVER CONTROL ====================

void opcontrol() {
    autonomousMode = false;
    setDriveBrakeMode(pros::E_MOTOR_BRAKE_COAST);
    
    while (true) {
        // Drivetrain
        int forward = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
        int turnLeft = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_X);
        int turnRight = master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);
        int turn = turnLeft + turnRight;
        
        omniDrive(forward, 0, turn);
        
        // Intake controls
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {
            outakeMiddle();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {
            outakeTop();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L1)) {
            outakeBottom();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_L2)) {
            outakeStorage();
        }
        else {
            stopIntake();
        }
        
        // Pneumatics
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_X)) {
            deployScooper();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_B)) {
            retractScooper();
        }
        
        // Manual controls for specific motors
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_A)) {
            motor6CCW();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_Y)) {
            motor6CW();
        }
        
        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_LEFT)) {
            motor8CW();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_RIGHT)) {
            motor8CCW();
        }

        if (master.get_digital(pros::E_CONTROLLER_DIGITAL_UP)) {
            motor10CCW();
        }
        else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_DOWN)) {
            motor10CW();
        }
        
        pros::delay(MAIN_LOOP_DELAY);
    }
}